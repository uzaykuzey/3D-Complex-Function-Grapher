//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.7.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from MathParser.g4 by ANTLR 4.7.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.7.2")]
[System.CLSCompliant(false)]
public partial class MathParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		E=1, PI=2, PHI=3, X=4, Y=5, Z=6, EXP=7, POW=8, SQRT=9, CBRT=10, SIN=11, 
		COS=12, TAN=13, COT=14, SEC=15, CSC=16, ARG=17, ASIN=18, ACOS=19, ATAN=20, 
		ACOT=21, SI=22, LN=23, LOG=24, ABS=25, RE=26, IM=27, GAMMA=28, ZETA=29, 
		SIGN=30, W=31, ERF=32, BETA=33, PRODUCT=34, SUM=35, I=36, APERY=37, EULERMASCHERONI=38, 
		INTEGER=39, RATIONAL=40, ITERATIVE_VARIABLE=41, LP=42, RP=43, COMMA=44, 
		PLUS=45, MINUS=46, TIMES=47, DIVIDE=48, MOD=49, ABSSYMBOL=50, EXPSYMBOL=51, 
		WHITESPACE=52, NEWLINE=53;
	public const int
		RULE_add_expr = 0, RULE_mult_expr = 1, RULE_exp_expr = 2, RULE_final_expr = 3, 
		RULE_exp_op = 4, RULE_add_op = 5, RULE_mult_op = 6, RULE_int_declaration_for_iteration = 7, 
		RULE_function = 8, RULE_constant = 9, RULE_variable = 10, RULE_sum_or_product = 11;
	public static readonly string[] ruleNames = {
		"add_expr", "mult_expr", "exp_expr", "final_expr", "exp_op", "add_op", 
		"mult_op", "int_declaration_for_iteration", "function", "constant", "variable", 
		"sum_or_product"
	};

	private static readonly string[] _LiteralNames = {
		null, "'e'", "'pi'", "'phi'", "'x'", "'y'", "'z'", "'exp'", "'pow'", "'sqrt'", 
		"'cbrt'", "'sin'", "'cos'", "'tan'", "'cot'", "'sec'", "'csc'", "'arg'", 
		"'arcsin'", "'arccos'", "'arctan'", "'arccot'", "'si'", "'ln'", "'log'", 
		"'abs'", null, null, "'gamma'", "'zeta'", "'sign'", null, "'erf'", "'beta'", 
		"'product'", "'sum'", "'i'", "'apery'", "'eulerm'", null, null, null, 
		"'('", "')'", "','", "'+'", "'-'", "'*'", "'/'", "'%'", "'|'", null, null, 
		"'\n'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "E", "PI", "PHI", "X", "Y", "Z", "EXP", "POW", "SQRT", "CBRT", "SIN", 
		"COS", "TAN", "COT", "SEC", "CSC", "ARG", "ASIN", "ACOS", "ATAN", "ACOT", 
		"SI", "LN", "LOG", "ABS", "RE", "IM", "GAMMA", "ZETA", "SIGN", "W", "ERF", 
		"BETA", "PRODUCT", "SUM", "I", "APERY", "EULERMASCHERONI", "INTEGER", 
		"RATIONAL", "ITERATIVE_VARIABLE", "LP", "RP", "COMMA", "PLUS", "MINUS", 
		"TIMES", "DIVIDE", "MOD", "ABSSYMBOL", "EXPSYMBOL", "WHITESPACE", "NEWLINE"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "MathParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static MathParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public MathParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public MathParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}
	public partial class Add_exprContext : ParserRuleContext {
		public Add_opContext add_op() {
			return GetRuleContext<Add_opContext>(0);
		}
		public Add_exprContext add_expr() {
			return GetRuleContext<Add_exprContext>(0);
		}
		public Mult_exprContext mult_expr() {
			return GetRuleContext<Mult_exprContext>(0);
		}
		public Add_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_add_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterAdd_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitAdd_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdd_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Add_exprContext add_expr() {
		return add_expr(0);
	}

	private Add_exprContext add_expr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Add_exprContext _localctx = new Add_exprContext(Context, _parentState);
		Add_exprContext _prevctx = _localctx;
		int _startState = 0;
		EnterRecursionRule(_localctx, 0, RULE_add_expr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 29;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
				{
				State = 25; add_op();
				State = 26; add_expr(2);
				}
				break;
			case E:
			case PI:
			case PHI:
			case X:
			case Y:
			case Z:
			case EXP:
			case POW:
			case SQRT:
			case CBRT:
			case SIN:
			case COS:
			case TAN:
			case COT:
			case SEC:
			case CSC:
			case ARG:
			case ASIN:
			case ACOS:
			case ATAN:
			case ACOT:
			case SI:
			case LN:
			case LOG:
			case ABS:
			case RE:
			case IM:
			case GAMMA:
			case ZETA:
			case SIGN:
			case W:
			case ERF:
			case BETA:
			case PRODUCT:
			case SUM:
			case I:
			case APERY:
			case EULERMASCHERONI:
			case INTEGER:
			case RATIONAL:
			case ITERATIVE_VARIABLE:
			case LP:
			case ABSSYMBOL:
				{
				State = 28; mult_expr(0);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			Context.Stop = TokenStream.LT(-1);
			State = 37;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,1,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new Add_exprContext(_parentctx, _parentState);
					PushNewRecursionContext(_localctx, _startState, RULE_add_expr);
					State = 31;
					if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
					State = 32; add_op();
					State = 33; mult_expr(0);
					}
					} 
				}
				State = 39;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,1,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Mult_exprContext : ParserRuleContext {
		public Exp_exprContext exp_expr() {
			return GetRuleContext<Exp_exprContext>(0);
		}
		public Mult_exprContext mult_expr() {
			return GetRuleContext<Mult_exprContext>(0);
		}
		public Mult_opContext mult_op() {
			return GetRuleContext<Mult_opContext>(0);
		}
		public Mult_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mult_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterMult_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitMult_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMult_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Mult_exprContext mult_expr() {
		return mult_expr(0);
	}

	private Mult_exprContext mult_expr(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		Mult_exprContext _localctx = new Mult_exprContext(Context, _parentState);
		Mult_exprContext _prevctx = _localctx;
		int _startState = 2;
		EnterRecursionRule(_localctx, 2, RULE_mult_expr, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			{
			State = 41; exp_expr();
			}
			Context.Stop = TokenStream.LT(-1);
			State = 51;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 49;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
					case 1:
						{
						_localctx = new Mult_exprContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_mult_expr);
						State = 43;
						if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
						State = 44; mult_op();
						State = 45; exp_expr();
						}
						break;
					case 2:
						{
						_localctx = new Mult_exprContext(_parentctx, _parentState);
						PushNewRecursionContext(_localctx, _startState, RULE_mult_expr);
						State = 47;
						if (!(Precpred(Context, 2))) throw new FailedPredicateException(this, "Precpred(Context, 2)");
						State = 48; exp_expr();
						}
						break;
					}
					} 
				}
				State = 53;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,3,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class Exp_exprContext : ParserRuleContext {
		public Final_exprContext final_expr() {
			return GetRuleContext<Final_exprContext>(0);
		}
		public Exp_opContext exp_op() {
			return GetRuleContext<Exp_opContext>(0);
		}
		public Exp_exprContext exp_expr() {
			return GetRuleContext<Exp_exprContext>(0);
		}
		public Exp_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exp_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterExp_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitExp_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExp_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exp_exprContext exp_expr() {
		Exp_exprContext _localctx = new Exp_exprContext(Context, State);
		EnterRule(_localctx, 4, RULE_exp_expr);
		try {
			State = 59;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 54; final_expr();
				State = 55; exp_op();
				State = 56; exp_expr();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 58; final_expr();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Final_exprContext : ParserRuleContext {
		public ConstantContext constant() {
			return GetRuleContext<ConstantContext>(0);
		}
		public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		public Final_exprContext final_expr() {
			return GetRuleContext<Final_exprContext>(0);
		}
		public ITerminalNode POW() { return GetToken(MathParser.POW, 0); }
		public ITerminalNode LP() { return GetToken(MathParser.LP, 0); }
		public Add_exprContext[] add_expr() {
			return GetRuleContexts<Add_exprContext>();
		}
		public Add_exprContext add_expr(int i) {
			return GetRuleContext<Add_exprContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(MathParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(MathParser.COMMA, i);
		}
		public ITerminalNode RP() { return GetToken(MathParser.RP, 0); }
		public ITerminalNode BETA() { return GetToken(MathParser.BETA, 0); }
		public ITerminalNode LOG() { return GetToken(MathParser.LOG, 0); }
		public Sum_or_productContext sum_or_product() {
			return GetRuleContext<Sum_or_productContext>(0);
		}
		public ITerminalNode ITERATIVE_VARIABLE() { return GetToken(MathParser.ITERATIVE_VARIABLE, 0); }
		public Int_declaration_for_iterationContext[] int_declaration_for_iteration() {
			return GetRuleContexts<Int_declaration_for_iterationContext>();
		}
		public Int_declaration_for_iterationContext int_declaration_for_iteration(int i) {
			return GetRuleContext<Int_declaration_for_iterationContext>(i);
		}
		public ITerminalNode[] ABSSYMBOL() { return GetTokens(MathParser.ABSSYMBOL); }
		public ITerminalNode ABSSYMBOL(int i) {
			return GetToken(MathParser.ABSSYMBOL, i);
		}
		public Final_exprContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_final_expr; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterFinal_expr(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitFinal_expr(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFinal_expr(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Final_exprContext final_expr() {
		Final_exprContext _localctx = new Final_exprContext(Context, State);
		EnterRule(_localctx, 6, RULE_final_expr);
		try {
			State = 108;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 61; constant();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 62; variable();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 63; function();
				State = 64; final_expr();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 66; Match(POW);
				State = 67; Match(LP);
				State = 68; add_expr(0);
				State = 69; Match(COMMA);
				State = 70; add_expr(0);
				State = 71; Match(RP);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 73; Match(BETA);
				State = 74; Match(LP);
				State = 75; add_expr(0);
				State = 76; Match(COMMA);
				State = 77; add_expr(0);
				State = 78; Match(RP);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 80; Match(LOG);
				State = 81; Match(LP);
				State = 82; add_expr(0);
				State = 83; Match(COMMA);
				State = 84; add_expr(0);
				State = 85; Match(RP);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 87; Match(LOG);
				State = 88; final_expr();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 89; sum_or_product();
				State = 90; Match(LP);
				State = 91; add_expr(0);
				State = 92; Match(COMMA);
				State = 93; Match(ITERATIVE_VARIABLE);
				State = 94; Match(COMMA);
				State = 95; int_declaration_for_iteration();
				State = 96; Match(COMMA);
				State = 97; int_declaration_for_iteration();
				State = 98; Match(RP);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 100; Match(ABSSYMBOL);
				State = 101; add_expr(0);
				State = 102; Match(ABSSYMBOL);
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 104; Match(LP);
				State = 105; add_expr(0);
				State = 106; Match(RP);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Exp_opContext : ParserRuleContext {
		public ITerminalNode EXPSYMBOL() { return GetToken(MathParser.EXPSYMBOL, 0); }
		public Exp_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_exp_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterExp_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitExp_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExp_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Exp_opContext exp_op() {
		Exp_opContext _localctx = new Exp_opContext(Context, State);
		EnterRule(_localctx, 8, RULE_exp_op);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 110; Match(EXPSYMBOL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Add_opContext : ParserRuleContext {
		public ITerminalNode PLUS() { return GetToken(MathParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(MathParser.MINUS, 0); }
		public Add_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_add_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterAdd_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitAdd_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdd_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Add_opContext add_op() {
		Add_opContext _localctx = new Add_opContext(Context, State);
		EnterRule(_localctx, 10, RULE_add_op);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			_la = TokenStream.LA(1);
			if ( !(_la==PLUS || _la==MINUS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Mult_opContext : ParserRuleContext {
		public ITerminalNode TIMES() { return GetToken(MathParser.TIMES, 0); }
		public ITerminalNode DIVIDE() { return GetToken(MathParser.DIVIDE, 0); }
		public ITerminalNode MOD() { return GetToken(MathParser.MOD, 0); }
		public Mult_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mult_op; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterMult_op(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitMult_op(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMult_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Mult_opContext mult_op() {
		Mult_opContext _localctx = new Mult_opContext(Context, State);
		EnterRule(_localctx, 12, RULE_mult_op);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 114;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << TIMES) | (1L << DIVIDE) | (1L << MOD))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Int_declaration_for_iterationContext : ParserRuleContext {
		public Add_opContext add_op() {
			return GetRuleContext<Add_opContext>(0);
		}
		public ITerminalNode INTEGER() { return GetToken(MathParser.INTEGER, 0); }
		public Int_declaration_for_iterationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_int_declaration_for_iteration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterInt_declaration_for_iteration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitInt_declaration_for_iteration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInt_declaration_for_iteration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Int_declaration_for_iterationContext int_declaration_for_iteration() {
		Int_declaration_for_iterationContext _localctx = new Int_declaration_for_iterationContext(Context, State);
		EnterRule(_localctx, 14, RULE_int_declaration_for_iteration);
		try {
			State = 120;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PLUS:
			case MINUS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 116; add_op();
				State = 117; Match(INTEGER);
				}
				break;
			case INTEGER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 119; Match(INTEGER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionContext : ParserRuleContext {
		public ITerminalNode EXP() { return GetToken(MathParser.EXP, 0); }
		public ITerminalNode SQRT() { return GetToken(MathParser.SQRT, 0); }
		public ITerminalNode CBRT() { return GetToken(MathParser.CBRT, 0); }
		public ITerminalNode SIN() { return GetToken(MathParser.SIN, 0); }
		public ITerminalNode COS() { return GetToken(MathParser.COS, 0); }
		public ITerminalNode TAN() { return GetToken(MathParser.TAN, 0); }
		public ITerminalNode COT() { return GetToken(MathParser.COT, 0); }
		public ITerminalNode SEC() { return GetToken(MathParser.SEC, 0); }
		public ITerminalNode CSC() { return GetToken(MathParser.CSC, 0); }
		public ITerminalNode ASIN() { return GetToken(MathParser.ASIN, 0); }
		public ITerminalNode ACOS() { return GetToken(MathParser.ACOS, 0); }
		public ITerminalNode ATAN() { return GetToken(MathParser.ATAN, 0); }
		public ITerminalNode ACOT() { return GetToken(MathParser.ACOT, 0); }
		public ITerminalNode LN() { return GetToken(MathParser.LN, 0); }
		public ITerminalNode ABS() { return GetToken(MathParser.ABS, 0); }
		public ITerminalNode RE() { return GetToken(MathParser.RE, 0); }
		public ITerminalNode IM() { return GetToken(MathParser.IM, 0); }
		public ITerminalNode GAMMA() { return GetToken(MathParser.GAMMA, 0); }
		public ITerminalNode ZETA() { return GetToken(MathParser.ZETA, 0); }
		public ITerminalNode W() { return GetToken(MathParser.W, 0); }
		public ITerminalNode ERF() { return GetToken(MathParser.ERF, 0); }
		public ITerminalNode ARG() { return GetToken(MathParser.ARG, 0); }
		public ITerminalNode SI() { return GetToken(MathParser.SI, 0); }
		public ITerminalNode SIGN() { return GetToken(MathParser.SIGN, 0); }
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 16, RULE_function);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 122;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EXP) | (1L << SQRT) | (1L << CBRT) | (1L << SIN) | (1L << COS) | (1L << TAN) | (1L << COT) | (1L << SEC) | (1L << CSC) | (1L << ARG) | (1L << ASIN) | (1L << ACOS) | (1L << ATAN) | (1L << ACOT) | (1L << SI) | (1L << LN) | (1L << ABS) | (1L << RE) | (1L << IM) | (1L << GAMMA) | (1L << ZETA) | (1L << SIGN) | (1L << W) | (1L << ERF))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		public ITerminalNode INTEGER() { return GetToken(MathParser.INTEGER, 0); }
		public ITerminalNode RATIONAL() { return GetToken(MathParser.RATIONAL, 0); }
		public ITerminalNode I() { return GetToken(MathParser.I, 0); }
		public ITerminalNode E() { return GetToken(MathParser.E, 0); }
		public ITerminalNode PI() { return GetToken(MathParser.PI, 0); }
		public ITerminalNode PHI() { return GetToken(MathParser.PHI, 0); }
		public ITerminalNode APERY() { return GetToken(MathParser.APERY, 0); }
		public ITerminalNode EULERMASCHERONI() { return GetToken(MathParser.EULERMASCHERONI, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstant(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(Context, State);
		EnterRule(_localctx, 18, RULE_constant);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << E) | (1L << PI) | (1L << PHI) | (1L << I) | (1L << APERY) | (1L << EULERMASCHERONI) | (1L << INTEGER) | (1L << RATIONAL))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableContext : ParserRuleContext {
		public ITerminalNode X() { return GetToken(MathParser.X, 0); }
		public ITerminalNode Y() { return GetToken(MathParser.Y, 0); }
		public ITerminalNode Z() { return GetToken(MathParser.Z, 0); }
		public ITerminalNode ITERATIVE_VARIABLE() { return GetToken(MathParser.ITERATIVE_VARIABLE, 0); }
		public VariableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableContext variable() {
		VariableContext _localctx = new VariableContext(Context, State);
		EnterRule(_localctx, 20, RULE_variable);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 126;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << X) | (1L << Y) | (1L << Z) | (1L << ITERATIVE_VARIABLE))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Sum_or_productContext : ParserRuleContext {
		public ITerminalNode SUM() { return GetToken(MathParser.SUM, 0); }
		public ITerminalNode PRODUCT() { return GetToken(MathParser.PRODUCT, 0); }
		public Sum_or_productContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_sum_or_product; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.EnterSum_or_product(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathParserListener typedListener = listener as IMathParserListener;
			if (typedListener != null) typedListener.ExitSum_or_product(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathParserVisitor<TResult> typedVisitor = visitor as IMathParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSum_or_product(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Sum_or_productContext sum_or_product() {
		Sum_or_productContext _localctx = new Sum_or_productContext(Context, State);
		EnterRule(_localctx, 22, RULE_sum_or_product);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 128;
			_la = TokenStream.LA(1);
			if ( !(_la==PRODUCT || _la==SUM) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 0: return add_expr_sempred((Add_exprContext)_localctx, predIndex);
		case 1: return mult_expr_sempred((Mult_exprContext)_localctx, predIndex);
		}
		return true;
	}
	private bool add_expr_sempred(Add_exprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 3);
		}
		return true;
	}
	private bool mult_expr_sempred(Mult_exprContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1: return Precpred(Context, 3);
		case 2: return Precpred(Context, 2);
		}
		return true;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x37', '\x85', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x5', '\x2', ' ', '\n', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\a', '\x2', 
		'&', '\n', '\x2', '\f', '\x2', '\xE', '\x2', ')', '\v', '\x2', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', 
		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\a', '\x3', '\x34', 
		'\n', '\x3', '\f', '\x3', '\xE', '\x3', '\x37', '\v', '\x3', '\x3', '\x4', 
		'\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x5', '\x4', 
		'>', '\n', '\x4', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', 
		'\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x5', '\x5', 'o', '\n', '\x5', 
		'\x3', '\x6', '\x3', '\x6', '\x3', '\a', '\x3', '\a', '\x3', '\b', '\x3', 
		'\b', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x5', '\t', 
		'{', '\n', '\t', '\x3', '\n', '\x3', '\n', '\x3', '\v', '\x3', '\v', '\x3', 
		'\f', '\x3', '\f', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x2', '\x4', 
		'\x2', '\x4', '\xE', '\x2', '\x4', '\x6', '\b', '\n', '\f', '\xE', '\x10', 
		'\x12', '\x14', '\x16', '\x18', '\x2', '\b', '\x3', '\x2', '/', '\x30', 
		'\x3', '\x2', '\x31', '\x33', '\x5', '\x2', '\t', '\t', '\v', '\x19', 
		'\x1B', '\"', '\x4', '\x2', '\x3', '\x5', '&', '*', '\x4', '\x2', '\x6', 
		'\b', '+', '+', '\x3', '\x2', '$', '%', '\x2', '\x87', '\x2', '\x1F', 
		'\x3', '\x2', '\x2', '\x2', '\x4', '*', '\x3', '\x2', '\x2', '\x2', '\x6', 
		'=', '\x3', '\x2', '\x2', '\x2', '\b', 'n', '\x3', '\x2', '\x2', '\x2', 
		'\n', 'p', '\x3', '\x2', '\x2', '\x2', '\f', 'r', '\x3', '\x2', '\x2', 
		'\x2', '\xE', 't', '\x3', '\x2', '\x2', '\x2', '\x10', 'z', '\x3', '\x2', 
		'\x2', '\x2', '\x12', '|', '\x3', '\x2', '\x2', '\x2', '\x14', '~', '\x3', 
		'\x2', '\x2', '\x2', '\x16', '\x80', '\x3', '\x2', '\x2', '\x2', '\x18', 
		'\x82', '\x3', '\x2', '\x2', '\x2', '\x1A', '\x1B', '\b', '\x2', '\x1', 
		'\x2', '\x1B', '\x1C', '\x5', '\f', '\a', '\x2', '\x1C', '\x1D', '\x5', 
		'\x2', '\x2', '\x4', '\x1D', ' ', '\x3', '\x2', '\x2', '\x2', '\x1E', 
		' ', '\x5', '\x4', '\x3', '\x2', '\x1F', '\x1A', '\x3', '\x2', '\x2', 
		'\x2', '\x1F', '\x1E', '\x3', '\x2', '\x2', '\x2', ' ', '\'', '\x3', '\x2', 
		'\x2', '\x2', '!', '\"', '\f', '\x5', '\x2', '\x2', '\"', '#', '\x5', 
		'\f', '\a', '\x2', '#', '$', '\x5', '\x4', '\x3', '\x2', '$', '&', '\x3', 
		'\x2', '\x2', '\x2', '%', '!', '\x3', '\x2', '\x2', '\x2', '&', ')', '\x3', 
		'\x2', '\x2', '\x2', '\'', '%', '\x3', '\x2', '\x2', '\x2', '\'', '(', 
		'\x3', '\x2', '\x2', '\x2', '(', '\x3', '\x3', '\x2', '\x2', '\x2', ')', 
		'\'', '\x3', '\x2', '\x2', '\x2', '*', '+', '\b', '\x3', '\x1', '\x2', 
		'+', ',', '\x5', '\x6', '\x4', '\x2', ',', '\x35', '\x3', '\x2', '\x2', 
		'\x2', '-', '.', '\f', '\x5', '\x2', '\x2', '.', '/', '\x5', '\xE', '\b', 
		'\x2', '/', '\x30', '\x5', '\x6', '\x4', '\x2', '\x30', '\x34', '\x3', 
		'\x2', '\x2', '\x2', '\x31', '\x32', '\f', '\x4', '\x2', '\x2', '\x32', 
		'\x34', '\x5', '\x6', '\x4', '\x2', '\x33', '-', '\x3', '\x2', '\x2', 
		'\x2', '\x33', '\x31', '\x3', '\x2', '\x2', '\x2', '\x34', '\x37', '\x3', 
		'\x2', '\x2', '\x2', '\x35', '\x33', '\x3', '\x2', '\x2', '\x2', '\x35', 
		'\x36', '\x3', '\x2', '\x2', '\x2', '\x36', '\x5', '\x3', '\x2', '\x2', 
		'\x2', '\x37', '\x35', '\x3', '\x2', '\x2', '\x2', '\x38', '\x39', '\x5', 
		'\b', '\x5', '\x2', '\x39', ':', '\x5', '\n', '\x6', '\x2', ':', ';', 
		'\x5', '\x6', '\x4', '\x2', ';', '>', '\x3', '\x2', '\x2', '\x2', '<', 
		'>', '\x5', '\b', '\x5', '\x2', '=', '\x38', '\x3', '\x2', '\x2', '\x2', 
		'=', '<', '\x3', '\x2', '\x2', '\x2', '>', '\a', '\x3', '\x2', '\x2', 
		'\x2', '?', 'o', '\x5', '\x14', '\v', '\x2', '@', 'o', '\x5', '\x16', 
		'\f', '\x2', '\x41', '\x42', '\x5', '\x12', '\n', '\x2', '\x42', '\x43', 
		'\x5', '\b', '\x5', '\x2', '\x43', 'o', '\x3', '\x2', '\x2', '\x2', '\x44', 
		'\x45', '\a', '\n', '\x2', '\x2', '\x45', '\x46', '\a', ',', '\x2', '\x2', 
		'\x46', 'G', '\x5', '\x2', '\x2', '\x2', 'G', 'H', '\a', '.', '\x2', '\x2', 
		'H', 'I', '\x5', '\x2', '\x2', '\x2', 'I', 'J', '\a', '-', '\x2', '\x2', 
		'J', 'o', '\x3', '\x2', '\x2', '\x2', 'K', 'L', '\a', '#', '\x2', '\x2', 
		'L', 'M', '\a', ',', '\x2', '\x2', 'M', 'N', '\x5', '\x2', '\x2', '\x2', 
		'N', 'O', '\a', '.', '\x2', '\x2', 'O', 'P', '\x5', '\x2', '\x2', '\x2', 
		'P', 'Q', '\a', '-', '\x2', '\x2', 'Q', 'o', '\x3', '\x2', '\x2', '\x2', 
		'R', 'S', '\a', '\x1A', '\x2', '\x2', 'S', 'T', '\a', ',', '\x2', '\x2', 
		'T', 'U', '\x5', '\x2', '\x2', '\x2', 'U', 'V', '\a', '.', '\x2', '\x2', 
		'V', 'W', '\x5', '\x2', '\x2', '\x2', 'W', 'X', '\a', '-', '\x2', '\x2', 
		'X', 'o', '\x3', '\x2', '\x2', '\x2', 'Y', 'Z', '\a', '\x1A', '\x2', '\x2', 
		'Z', 'o', '\x5', '\b', '\x5', '\x2', '[', '\\', '\x5', '\x18', '\r', '\x2', 
		'\\', ']', '\a', ',', '\x2', '\x2', ']', '^', '\x5', '\x2', '\x2', '\x2', 
		'^', '_', '\a', '.', '\x2', '\x2', '_', '`', '\a', '+', '\x2', '\x2', 
		'`', '\x61', '\a', '.', '\x2', '\x2', '\x61', '\x62', '\x5', '\x10', '\t', 
		'\x2', '\x62', '\x63', '\a', '.', '\x2', '\x2', '\x63', '\x64', '\x5', 
		'\x10', '\t', '\x2', '\x64', '\x65', '\a', '-', '\x2', '\x2', '\x65', 
		'o', '\x3', '\x2', '\x2', '\x2', '\x66', 'g', '\a', '\x34', '\x2', '\x2', 
		'g', 'h', '\x5', '\x2', '\x2', '\x2', 'h', 'i', '\a', '\x34', '\x2', '\x2', 
		'i', 'o', '\x3', '\x2', '\x2', '\x2', 'j', 'k', '\a', ',', '\x2', '\x2', 
		'k', 'l', '\x5', '\x2', '\x2', '\x2', 'l', 'm', '\a', '-', '\x2', '\x2', 
		'm', 'o', '\x3', '\x2', '\x2', '\x2', 'n', '?', '\x3', '\x2', '\x2', '\x2', 
		'n', '@', '\x3', '\x2', '\x2', '\x2', 'n', '\x41', '\x3', '\x2', '\x2', 
		'\x2', 'n', '\x44', '\x3', '\x2', '\x2', '\x2', 'n', 'K', '\x3', '\x2', 
		'\x2', '\x2', 'n', 'R', '\x3', '\x2', '\x2', '\x2', 'n', 'Y', '\x3', '\x2', 
		'\x2', '\x2', 'n', '[', '\x3', '\x2', '\x2', '\x2', 'n', '\x66', '\x3', 
		'\x2', '\x2', '\x2', 'n', 'j', '\x3', '\x2', '\x2', '\x2', 'o', '\t', 
		'\x3', '\x2', '\x2', '\x2', 'p', 'q', '\a', '\x35', '\x2', '\x2', 'q', 
		'\v', '\x3', '\x2', '\x2', '\x2', 'r', 's', '\t', '\x2', '\x2', '\x2', 
		's', '\r', '\x3', '\x2', '\x2', '\x2', 't', 'u', '\t', '\x3', '\x2', '\x2', 
		'u', '\xF', '\x3', '\x2', '\x2', '\x2', 'v', 'w', '\x5', '\f', '\a', '\x2', 
		'w', 'x', '\a', ')', '\x2', '\x2', 'x', '{', '\x3', '\x2', '\x2', '\x2', 
		'y', '{', '\a', ')', '\x2', '\x2', 'z', 'v', '\x3', '\x2', '\x2', '\x2', 
		'z', 'y', '\x3', '\x2', '\x2', '\x2', '{', '\x11', '\x3', '\x2', '\x2', 
		'\x2', '|', '}', '\t', '\x4', '\x2', '\x2', '}', '\x13', '\x3', '\x2', 
		'\x2', '\x2', '~', '\x7F', '\t', '\x5', '\x2', '\x2', '\x7F', '\x15', 
		'\x3', '\x2', '\x2', '\x2', '\x80', '\x81', '\t', '\x6', '\x2', '\x2', 
		'\x81', '\x17', '\x3', '\x2', '\x2', '\x2', '\x82', '\x83', '\t', '\a', 
		'\x2', '\x2', '\x83', '\x19', '\x3', '\x2', '\x2', '\x2', '\t', '\x1F', 
		'\'', '\x33', '\x35', '=', 'n', 'z',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
